# オブジェクト指向プログラミング課題（Java） / Object-Oriented Programming Project

## 概要（日本語）

このプロジェクトは、エルサレム・ヘブライ大学のオブジェクト指向プログラミング（OOP）の授業で実装した課題です。  
課題のテーマは「無限に続く 2D の世界をシミュレーションするゲーム風アプリケーション」で、以下の要素を実装しています。

- Perlin Noise を用いた、左右にどこまでも続く地形生成  
- 地形に生える木（Tree）と、その上に配置される葉（Leaf）  
- 空（Sky）と太陽（Sun）、太陽を追従する Sun Halo  
- プレイヤーに相当するアバター（Avatar）と、そのエネルギーバー（EnergyCounter）  
- カメラが移動しても世界が途切れず続いて見えるようにするキャッシュ機構  

授業では、クラス・継承・インターフェース・ファクトリなどの OOP の知識を使って、  
「読みやすく拡張しやすいクラス設計」を行うことが求められました。

---

## 主な設計のポイント（日本語）

1. **Sun Halo と TrackerObject**  
   最初の設計では SunHalo を他の GameObject と同じように生成する想定でしたが、  
   実際には「太陽の位置を常に追いかける」オブジェクトが必要になったため、  
   `TrackerObject` というクラスを新しく作り、`GameObject` を継承して `update()` をオーバーライドしました。  
   これにより、SunHalo のような「別のオブジェクトを追跡するオブジェクト」を汎用的に扱えるようにしています。

2. **EnergyCounter（エネルギーバー）**  
   当初はアバター内部でエネルギーを管理する設計でしたが、  
   画面上に表示して毎フレーム再描画する必要があったため、  
   `EnergyCounter` を `GameObject` のサブクラスとして独立させ、`update()` をオーバーライドしました。  
   こうすることで、見た目や挙動を後から変更しやすくなっています。

3. **Canopy と LeafObject**  
   木の上に生える葉（落ち葉のアニメーションなど）を整理して実装するため、途中で `Canopy` クラスを追加しました。  
   `Canopy` が「葉の集合」を管理し、`LeafObject` は「1枚の葉」の挙動に集中させることで、  
   再帰的な生成やデバッグがしやすい構造にしています。

4. **無限（再帰的）な世界のシミュレーション**  
   要求として「無限に続くこと」と「同じ場所に戻ったときは同じ世界であること」の 2 つがありました。  
   そこで、Perlin Noise を利用し、同じシードから常に同じ地形・木・葉が生成されるようにしています。  

   - ゲーム開始時に Game Manager がシードを決める  
   - Terrain や Tree がそのシードから Perlin 関数を生成  
   - Perlin の値をもとに地形の高さや木のパラメータを決定  
   - 木から Canopy、Canopy から LeafObject へと値を渡し、葉の角度・透明度・寿命などを決定  

   これにより、世界は理論上どこまでも続きますが、同じ座標に戻れば同じ景色が再現されます。

5. **Tree クラスとファクトリパターン**  
   `Tree` は「木を直接使うクラス」ではなく「木を生成するファクトリ」として設計しました。  
   API 仕様上、`Tree.createInRange()` のようなメソッドが求められていたため、  
   木は Terrain の一部としてのみ利用されることを前提にし、役割を限定しています。

6. **キャッシュによるパフォーマンス改善**  
   パフォーマンス向上のため、地形ブロックや Canopy などにはキャッシュを用意しています。  
   カメラが横方向に動くとき、画面から外れたオブジェクトを捨て、新しくフレーム内に入ってきた部分だけ生成し直します。  
   これにより、「無限に続く世界」を実現しつつ、描画負荷を抑えています。

---

## Overview (English)

This project was created for the Object-Oriented Programming course at the Hebrew University of Jerusalem.

The assignment was to implement a small game-like 2D world that appears infinite in both directions.  
The main features are:

- Terrain generated by Perlin noise, extending infinitely left and right  
- Trees and leaves placed on the terrain  
- A sky and sun, plus a Sun Halo that visually tracks the sun’s position  
- An avatar controlled by the player, with an on-screen energy bar  
- Caching logic so that the camera can move, but the world still appears continuous and responsive  

The focus of the assignment was on using OOP concepts learned in class (classes, inheritance, factory patterns, etc.) to design a clean and extensible codebase.

### Key design decisions

- A `TrackerObject` class extends `GameObject` and overrides `update()` so it can follow another object (for example, the Sun Halo following the sun). This allows us to implement “tracking” objects in a generic way.  
- The `EnergyCounter` was first planned to be internal to the `Avatar`, but because it needs to be rendered and updated every frame, it was refactored into its own `GameObject` subclass. This makes it easier to change its appearance and behavior.  
- A `Canopy` class was added to manage groups of leaves, while `LeafObject` handles the behavior of individual leaves. This makes recursive generation and debugging more manageable.  
- To meet the “infinite but reproducible world” requirement, Perlin noise is used with a fixed seed chosen at game start. Terrain, trees, canopies and leaves all receive parameters derived from this Perlin function, so the same position in the world always generates the same content.  
- The `Tree` class acts as a factory rather than a general-purpose tree object. It provides methods like `createInRange()` to generate trees only as part of the terrain, reflecting the intended API design.  
- Caching is used for terrain blocks and canopies to improve performance. Only objects inside (or slightly around) the current camera frame are kept; as the camera moves, objects leaving the frame are replaced by newly generated ones.

Overall, this project demonstrates my ability to design and implement a medium-sized Java application using object-oriented principles, while also paying attention to performance and code organization.
