aranw
elihas


Differences between the two UML versions:
There are a few differences to be noted between the two UMLs:
1.It can be seen that the Sun Halo class was intended to be created in a similar fashion to sky and sun,
by creating a new GameObject in the static create function instead of creating an instance of a new sub class
TrackerObject that extends GameObject. The class TrackerObject was made in order to override the update 
function to be able to set the halo to track the sun. In a similar fashion any TrackerObject function will be
able to track another object given in a similar fashion.

2.As can be seen, EnergyCounter class got added to the world package.
Originally, the energy counter was meant to be implemented internally in Avatar.
However, in order to be able to update the counter in a way that will be shown on screen and re-rendered
per update, there was a need to make EnergyCounter extend GameObject and override the update function.
For this reason, EnergyCounter class was created as an easy way to make those changes and also an easy way
in case we want to change or update the appearance or the functionality of the energy bar.

3.As can be seen at the start, a class to handle the Canopy wasn't taken into consideration at the first
UML. Class Canopy got added while working on the falling leaves in order to generate the recursively falling
leaves and it's neighbors in a more organized and efficient way.
By adding Canopy we could also make sure that LeafObject class will be a class in charge of a the behaviour
of every single leaf instances, which is more readable and also serves as a better implementation in case
of debugging or if there is a need to make changes.

Simulating an Infinite (recurring) world:
The requirement was 2-fold:
    - A world which goes on forever.
    - A world that doesn't change were you to return to a former location.
The perlinNoise function has both of these qualities - it is infinite, but also pseudrandom
and can be identically reproduced.
the infinite world(not including sun, sky, yoshi,..) is based off the terrain and the trees(canopy and leaf).

The perlin function is generated and employed in the following process:
The game Manager randomizes a seed(from the epoch of the initiation of the game),
this seed is given to the terrain which feeds it to a PerlinNoise class instance.
    - The class uses it in the process of generating the perlin function - and thus a perlin function is set.
    - The perlin function(after scaling) determines the height of each ground column.
The tree class(which generates the trees themselves) receives the seed as well,
and initializes a PerlinNoise instance of it's own.
each tree then receive an (int) parameter based off the perlin value.
the tree seeds a Random class instance and uses it to seed the canopy.
the canopy does the same with the leafObject.
The leaf objects use the value to determine their angle opaqueness durations of their life cycle.

Thus every construct of the infinite world, had received(in turn)a parameter based on the perlin value.
this means that since the epoch of the game - every time the world object will be created - it will be
created in the same way as it did before.


The design of the Tree Object:
The Tree class is only the tree factory, and no access to a Tree access is given.
This is to prevent other uses for trees rather than being a part of the terrain.
This is because the API specified to have the method createInRange() in Tree in the first place,
So it must have been the intention of the client.


Regarding Caches:
To improve the latency of the game, trees canopies and terrain blocks all have caches.
The cache holds only those game objects that are in the frame(and perhaps a portion beyond it).
So when the camera moves(when it is triggered by the avatar movement) say to the right,
the objects from the left are replaced by the new objects that enter the frame.
This is done with two indices that follow the framed space(terrainedSpace), and update according
to the range required by createInRange().
